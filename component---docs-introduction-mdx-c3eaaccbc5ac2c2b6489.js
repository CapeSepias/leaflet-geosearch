(window.webpackJsonp=window.webpackJsonp||[]).push([[4],{AtMm:function(e,t,o){"use strict";o.r(t),o.d(t,"_frontmatter",(function(){return l})),o.d(t,"default",(function(){return d}));o("5hJT"),o("W1QL"),o("K/PF"),o("t91x"),o("75LO"),o("PJhk");var r=o("/FXl"),n=o("TjRS"),a=o("ZFoC"),i=o("KUxS"),p=o("yYOO");o("aD51");function s(){return(s=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var o=arguments[t];for(var r in o)Object.prototype.hasOwnProperty.call(o,r)&&(e[r]=o[r])}return e}).apply(this,arguments)}var l={};void 0!==l&&l&&l===Object(l)&&Object.isExtensible(l)&&!l.hasOwnProperty("__filemeta")&&Object.defineProperty(l,"__filemeta",{configurable:!0,value:{name:"_frontmatter",filename:"docs/introduction.mdx"}});var b={_frontmatter:l},c=n.a;function d(e){var t,o=e.components,d=function(e,t){if(null==e)return{};var o,r,n={},a=Object.keys(e);for(r=0;r<a.length;r++)o=a[r],t.indexOf(o)>=0||(n[o]=e[o]);return n}(e,["components"]);return Object(r.b)(c,s({},b,d,{components:o,mdxType:"MDXLayout"}),Object(r.b)("h1",{id:"introduction"},"Introduction"),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"leaflet-geosearch")," adds support for geocoding (address lookup, a.k.a. geoseaching) to your (web) application. It comes with controls to be embedded in your Leaflet map."),Object(r.b)("p",null,"We support the following providers out-of-the-box; ",Object(r.b)("a",s({parentName:"p"},{href:"/providers/bing"}),"Bing"),", ",Object(r.b)("a",s({parentName:"p"},{href:"/providers/esri"}),"Esri"),", ",Object(r.b)("a",s({parentName:"p"},{href:"/providers/google"}),"Google"),", ",Object(r.b)("a",s({parentName:"p"},{href:"/providers/openstreetmap"}),"OpenStreetMap"),", ",Object(r.b)("a",s({parentName:"p"},{href:"/providers/locationiq"}),"LocationIQ"),", ",Object(r.b)("a",s({parentName:"p"},{href:"/providers/opencage"}),"OpenCage"),"."),Object(r.b)("p",null,"Although this project is named ",Object(r.b)("inlineCode",{parentName:"p"},"leaflet-geosearch"),", this library is also usable without LeafletJS, and does not have any dependencies on Leaflet whatsoever."),Object(r.b)(i.a,{__position:0,__code:"<Map />",__scope:(t={props:d,DefaultLayout:n.a,Link:a.b,Playground:i.a,Map:p.a},t.DefaultLayout=n.a,t._frontmatter=l,t),mdxType:"Playground"},Object(r.b)(p.a,{mdxType:"Map"})),Object(r.b)("h2",{id:"installation"},"Installation"),Object(r.b)("pre",null,Object(r.b)("code",s({parentName:"pre"},{className:"language-bash"}),"npm install leaflet-geosearch\n")),Object(r.b)("h2",{id:"providers"},"Providers"),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"leaflet-geosearch"),' uses so-called "providers" to take care of building the correct service URL and parsing the retrieved data into a uniform format. Thanks to this architecture, it is trivial to add your own providers, so you can use your own geocoding service.'),Object(r.b)("p",null,"When ",Object(r.b)("a",s({parentName:"p"},{href:"/providers/openstreet"}),Object(r.b)("inlineCode",{parentName:"a"},"OpenStreetMap"))," does not match your needs; you can also choose to use the ",Object(r.b)("a",s({parentName:"p"},{href:"/providers/bing"}),Object(r.b)("inlineCode",{parentName:"a"},"Bing")),", ",Object(r.b)("a",s({parentName:"p"},{href:"/providers/esri"}),Object(r.b)("inlineCode",{parentName:"a"},"Esri")),", ",Object(r.b)("a",s({parentName:"p"},{href:"/providers/google"}),Object(r.b)("inlineCode",{parentName:"a"},"Google")),", ",Object(r.b)("a",s({parentName:"p"},{href:"/providers/locationiq"}),Object(r.b)("inlineCode",{parentName:"a"},"LocationIQ")),", or ",Object(r.b)("a",s({parentName:"p"},{href:"/providers/opencage"}),Object(r.b)("inlineCode",{parentName:"a"},"OpenCage"))," providers. Most of those providers do however require ",Object(r.b)("inlineCode",{parentName:"p"},"API keys"),". See the documentation pages on the relevant organisations on how to obtain these keys."),Object(r.b)("p",null,"In case you decide to write your own provider, please consider submitting a PR to share your work with us."),Object(r.b)("p",null,"Providers are unaware of any options you can give them. They are simple proxies to their endpoints. There is only one special property, and that is the ",Object(r.b)("inlineCode",{parentName:"p"},"params")," option. The difference being; that ",Object(r.b)("inlineCode",{parentName:"p"},"params")," will be included in the endpoint url. Being Often used for ",Object(r.b)("inlineCode",{parentName:"p"},"API KEYS"),", while the other attributes can be used for provider configuration."),Object(r.b)("h2",{id:"browser-support--polyfills"},"Browser support / Polyfills"),Object(r.b)("p",null,"This project is written with the latest technologies in mind. Thereby it is required to include some polyfills when you wish to support older browsers. These polyfills are recommended for IE and Safari support:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",s({parentName:"li"},{href:"https://npm.im/babel-polyfill"}),"babel-polyfill"),", for ",Object(r.b)("inlineCode",{parentName:"li"},"array.includes")," support."),Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",s({parentName:"li"},{href:"https://npm.im/unfetch"}),"unfetch"),", for ",Object(r.b)("inlineCode",{parentName:"li"},"fetch")," requests.")))}void 0!==d&&d&&d===Object(d)&&Object.isExtensible(d)&&!d.hasOwnProperty("__filemeta")&&Object.defineProperty(d,"__filemeta",{configurable:!0,value:{name:"MDXContent",filename:"docs/introduction.mdx"}}),d.isMDXComponent=!0}}]);